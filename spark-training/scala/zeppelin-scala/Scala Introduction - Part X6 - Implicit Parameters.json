{"paragraphs":[{"text":"%md\n# Implcit Parameters\nThis example is taken from the official Scala documentation and uses a structure from abstract algebra to show how implicit parameters work.\n\n## Semigroup\nA semigroup is an algebraic structure on a set A with an (associative) operation, called add here, that combines a pair of A's and returns another A.","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>Implcit Parameters</h1>\n<p>This example is taken from the official Scala documentation and uses a structure from abstract algebra to show how implicit parameters work.</p>\n<h2>Semigroup</h2>\n<p>A semigroup is an algebraic structure on a set A with an (associative) operation, called add here, that combines a pair of A's and returns another A.</p>\n"}]},"apps":[],"jobName":"paragraph_1521656094909_-1440001139","id":"20170129-112050_2092779302","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:26"},{"text":"abstract class SemiGroup[A] {\n  def add(x: A, y: A): A\n}","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class SemiGroup\n"}]},"apps":[],"jobName":"paragraph_1521656094911_-1439231641","id":"20170129-111611_292719713","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:27"},{"text":"%md\n## Monoid\n\nA monoid is a semigroup with a distinguished element of A, called unit, that when combined with any other element of A returns that other element again.","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Monoid</h2>\n<p>A monoid is a semigroup with a distinguished element of A, called unit, that when combined with any other element of A returns that other element again.</p>\n"}]},"apps":[],"jobName":"paragraph_1521656094911_-1439231641","id":"20170129-112204_2041539516","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:28"},{"text":"abstract class Monoid[A] extends SemiGroup[A] {\n  def unit: A\n}","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined class Monoid\n"}]},"apps":[],"jobName":"paragraph_1521656094912_-1453467351","id":"20170129-112037_849005875","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:29"},{"text":"%md\nTo show how implicit parameters work, we first define monoids for strings and integers. The implicit keyword indicates that the corresponding object can be used implicitly, within this scope, as a parameter of a function marked implicit.","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>To show how implicit parameters work, we first define monoids for strings and integers. The implicit keyword indicates that the corresponding object can be used implicitly, within this scope, as a parameter of a function marked implicit.</p>\n"}]},"apps":[],"jobName":"paragraph_1521656094912_-1453467351","id":"20170129-112338_83164503","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:30"},{"text":"implicit object StringMonoid extends Monoid[String] {\n    def add(x: String, y: String): String = x concat y\n    def unit: String = \"\"\n}\nimplicit object IntMonoid extends Monoid[Int] {\n    def add(x: Int, y: Int): Int = x + y\n    def unit: Int = 0\n}","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ndefined object StringMonoid\n\ndefined object IntMonoid\n"}]},"apps":[],"jobName":"paragraph_1521656094913_-1453852100","id":"20170129-112251_2133971726","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:31"},{"text":"%md\n## Summing Up\n\nThis method takes a List[A] returns an A which represent the combined value of applying the monoid operation successively across the whole list. Making the parameter m implicit here means we only have to provide the xs parameter at the call site, since if we have a List[A] we know what type A actually is and therefore what type Monoid[A] is needed. We can then implicitly find whichever val or object in the current scope also has that type and use that without needing to specify it explicitly.","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Summing Up</h2>\n<p>This method takes a List[A] returns an A which represent the combined value of applying the monoid operation successively across the whole list. Making the parameter m implicit here means we only have to provide the xs parameter at the call site, since if we have a List[A] we know what type A actually is and therefore what type Monoid[A] is needed. We can then implicitly find whichever val or object in the current scope also has that type and use that without needing to specify it explicitly.</p>\n"}]},"apps":[],"jobName":"paragraph_1521656094913_-1453852100","id":"20170129-112308_245724678","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:32"},{"text":"def sum_all[A](xs: List[A])(implicit m: Monoid[A]): A = {\n    if (xs.isEmpty) m.unit\n    else m.add(xs.head, sum_all(xs.tail))\n}","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nsum_all: [A](xs: List[A])(implicit m: Monoid[A])A\n"}]},"apps":[],"jobName":"paragraph_1521656094913_-1453852100","id":"20170129-112419_189027157","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:33"},{"text":"%md\nHere we call sum twice, with only one parameter each time. Since the second parameter of sum, m, is implicit its value is looked up in the current scope, based on the type of monoid required in each case, meaning both expressions can be fully evaluated.\n","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<p>Here we call sum twice, with only one parameter each time. Since the second parameter of sum, m, is implicit its value is looked up in the current scope, based on the type of monoid required in each case, meaning both expressions can be fully evaluated.</p>\n"}]},"apps":[],"jobName":"paragraph_1521656094914_-1452697853","id":"20170129-112438_1909505127","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:34"},{"text":"println(sum_all(List(1, 2, 3)))          // uses IntMonoid implicitly","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"6\n"}]},"apps":[],"jobName":"paragraph_1521656094914_-1452697853","id":"20170129-112508_1896924361","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:35"},{"text":"println(sum_all(List(\"a\", \"b\", \"c\"))) // uses StringMonoid implicitly","dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"abc\n"}]},"apps":[],"jobName":"paragraph_1521656094915_-1453082602","id":"20170129-112526_700056827","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:36"},{"dateUpdated":"2018-03-21T18:14:54+0000","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1521656094915_-1453082602","id":"20170129-112649_5494678","dateCreated":"2018-03-21T18:14:54+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:37"}],"name":"Scala Introduction - Part X6 - Implicit Parameters","id":"2D9HN9RYU","angularObjects":{"2D8DSN3N4:shared_process":[],"2D7W55G1J:shared_process":[],"2DA3X6UGN:shared_process":[],"2D9HTU14T:shared_process":[],"2DBA6X8JB:shared_process":[],"2DBSCZXK2:shared_process":[],"2D9M853BP:shared_process":[],"2DAXFQ4X2:shared_process":[],"2DB3TEGGU:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}
